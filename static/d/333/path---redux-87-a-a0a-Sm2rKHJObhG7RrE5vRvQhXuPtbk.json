{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>This module contains helper functions for building redux-actions Actions. The preferred way to do this is to use the\nfollowing functions:</p>\n<ul>\n<li>createActionNoArgs</li>\n<li>createActionWithPayload</li>\n<li>createActionWithMeta</li>\n<li>createActionWithPayloadAndMeta</li>\n</ul>\n<p>These functions restrict the signatures of the Actions to have zero to many meta arguments and zero or one payload\narguments. Meta arguments are used to identify the data that is being manipulated in the redux store, and the\npayload argument is incoming data that is to be reduced.</p>\n<h4>Example Usage</h4>\n<pre><code class=\"language-javascript\">import {\n  createActionNoArgs,\n  createActionWithMeta,\n  createActionWithPayload,\n  createActionWithPayloadAndMeta,\n} from 'bandit-pouch';\n\n\nexport default {\n  // No meta or payload\n  requestList: createActionNoArgs('category.list@request'),\n\n  // No meta, payload contains an array of categories received from the endpoint\n  receiveList: createActionWithPayload('category.list@receive'),\n\n  // Meta identifies the category to store by alias\n  requestStore: createActionWithMeta('category.store@request', ['alias']),\n\n  // Meta identifies the category to store by alias, payload contains the just-stored category details\n  receiveStore: createActionWithPayloadAndMeta('category.store@receive', ['alias']),\n}\n</code></pre>\n<p>Actions are functions which create objects which are dispatched via redux and reduced into the store by reducers.</p>\n<h4>Example Usage</h4>\n<pre><code class=\"language-javascript\">// (Actions) Create an action\naction = createActionWithPayloadAndMeta('database.tables.columns@receive', ['alias', 'schema', 'table']);\n\n// (Component) Dispatch an action\ndispatch(action({ (payload) }, 'myAlias', 'mySchema', 'myTable');\n\n// (Reducers) Handle the dispatched action via a Reducer to reduce the new payload into the store\n[action]: (state, {error, payload, meta: {alias, schema, table}}) =>\n</code></pre>","frontmatter":{"id":"redux-actions","title":"Actions"}}},{"node":{"html":"<p>You can use this module to execute AJAX requests against REST API endpoints. It follows common development\npatterns that were frequently used in our projects. These methods heavily depend on how Redux Action handlers\nare constructed and used. You can find more in our example section where combine all our modules to\ncreate a reducer and actions that depend on a remote API. </p>\n<h4>Available methods:</h4>\n<ul>\n<li><em>requestList</em> - Executes a GET request against an list REST API endpoint</li>\n<li><em>requestDetails</em> - Executes a GET request against a details REST API endpoint</li>\n<li><em>requestStore</em> - Executes a POST or PUT request against a details REST API endpoint with resource attributes</li>\n<li><em>requestPatch</em> - Executes a PATCH request against a details REST API endpoint with resource attributes</li>\n<li><em>requestDelete</em> - Executes a DELETE request against a REST API endpoint</li>\n</ul>\n<h4>Example</h4>\n<p>Lets define common actions object that would be used to handle the Redux state.</p>\n<h5>actions.js</h5>\n<pre><code class=\"language-javascript\">import {\n  createActionNoArgs,\n  createActionWithMeta,\n  createActionWithPayload,\n  createActionWithPayloadAndMeta,\n} from 'bandit-pouch';\n\nexport default {\n  /* Actions used by the `requestList` function */\n  requestList: createActionNoArgs('resource.list@request'),\n  receiveList: createActionNoArgs('resource.list@receive'),\n  \n  /* Actions used by the `requestDetails` and `requestPatch` functions */\n  requestDetails: createActionWithMeta('resource.details@request', ['alias']),\n  receiveDetails: createActionWithPayloadAndMeta('resource.details@receive', ['alias']),\n  \n  /* Actions used by the `requestStore` function */\n  requestStore: createActionWithMeta('resource.store@request', ['alias']),\n  receiveStore: createActionWithPayloadAndMeta('resource.store@receive', ['alias']),\n  \n  /* Actions used by the `requestDelete` function */\n  requestDelete: createActionWithMeta('resource.delete@request', ['alias']),\n  receiveDelete: createActionWithPayloadAndMeta('resource.delete@receive', ['alias']),\n}\n</code></pre>\n<p>Once the actions are defined we can continue writing our dispatcher functions that would\nexecute the REST API and invoke defined Reducer actions.</p>\n<h5>dispatcher.js</h5>\n<pre><code class=\"language-javascript\">import {\n  requestList,\n  requestStore,\n  requestPatch,\n  requestDelete,\n  requestDetails,\n} from 'bandit-pouch';\nimport Actions from './actions'\n\nexport const getResources = dispatch => (queryParameters = {}) => dispatch(\n  requestList('/api/resources', queryParameters, Actions),\n);\n\nexport const getResource = dispatch => id => dispatch(\n  requestDetails(id, `/api/resources/${id}`, Actions),\n);\n\nexport const createResource = dispatch => payload => dispatch(\n  requestStore(null, payload, `/api/resources`, Actions, true),\n);\n\nexport const editResource = dispatch => (id, payload) => dispatch(\n  requestStore(id, payload, `/api/resources/${id}`, Actions),\n);\n\nexport const patchResource = dispatch => (id, payload) => dispatch(\n  requestPatch(id, payload, `/api/resources/${id}`, Actions),\n);\n\nexport const deleteResource = dispatch => id => dispatch(\n  requestDelete(id, `/api/resources/${id}`, Actions),\n);\n</code></pre>\n<p>Now let's define a simple Reducer that handles the Actions that are dispatched by our requests.\nWe are going to use <a href=\"https://github.com/redux-utilities/redux-actions\">redux-actions</a> library to\nreduce the amount of boilerplate code.</p>\n<h5>reducer.js</h5>\n<pre><code class=\"language-javascript\">import _ from 'lodash';\nimport { handleActions } from 'redux-actions';\nimport * as states from 'bandit-pouch/redux/states';\nimport {\n    assignInState,\n    mergeInState,\n    omitInState,\n    setInState,\n} from 'bandit-pouch/redux/reducers';\nimport Actions from './actions'\n\nconst initialState = {\n  resources: {\n    ...states.initial(),\n  },\n}\n\nexport default handleActions({\n  [Actions.requestList]: state => setInState(\n    state,\n    'resources',\n    states.loading(),\n  ),\n  [Actions.receiveList]: (state, { error, payload }) => {\n    if (error) {\n      return mergeInState(state, 'resources', states.error(payload))\n    }\n    // creates an object from the list of resource where the keys\n    // are resource unique identifiers\n    const resources = _.reduce(payload, (obj, resource) => {\n      return { obj, [resource.id]: resource };\n    }, state.resources);\n\n    return mergeInState(state, 'resources', states.found(resources));\n  },\n  \n  [Actions.requestDetails]: (state, { payload, meta: { alias } }) => assignInState(\n    state,\n    `resources.${alias}`,\n    states.loading()\n  ),\n  \n  [Actions.receiveDetails]: (state, { error, payload, meta: { alias } }) => assignInState(\n    state,\n    `resources.${alias}`,\n    error ? states.error(payload) : payload,\n  ),\n  \n  [Actions.requestStore]: (state, { payload, meta: { alias } }) => assignInState(\n    state,\n    `resources.${alias}`,\n    states.storing(),\n  ),\n  \n  [Actions.receiveStore]: (state, { error, payload, meta: { alias } }) => {\n    if (error) {\n      return assignInState(state, `resources.${alias}`, states.storeError(payload))\n    }\n    return setInState(state, `resources.${alias}`, states.stored(payload));\n  },\n  \n  [Actions.requestDelete]: (state, { payload, meta: { alias } }) => assignInState(\n    state,\n    `resources.${alias}`,\n    states.deleting(),\n  ),\n  \n  [Actions.receiveDelete]: (state, { error, meta: { alias } }) => {\n    if (error) {\n      return assignInState(state, `resources.${alias}`, {\n        error: payload,\n        deleting: false,\n      });\n    }\n    return omitInState(state, `resources.${alias}`);\n  },\n   \n}, initialState)\n</code></pre>","frontmatter":{"id":"redux-requests","title":"Requests"}}},{"node":{"html":"<p>This module exposes a couple of utility function that can help out in manipulating the state\nin the reducers.</p>\n<h4>Available methods:</h4>\n<ul>\n<li><em>setInState</em> - Sets a deep value in the redux state</li>\n<li><em>omitInState</em> - Omits a deep value in the redux state</li>\n<li><em>mergeInState</em> - Merge an object at a deep path in the redux state</li>\n<li><em>assignInState</em> - Assigns values from an object at a deep path in the redux state</li>\n</ul>\n<h4>Example Usage</h4>\n<p>Image a simple a User management reducer where you need to perform login, update and logout operations</p>\n<pre><code class=\"language-javascript\">import * as states from 'bandit-pouch/redux/states';\nimport {\n  setInState,\n  omitInState,\n  mergeInState,\n  assignInState,\n} from 'bandit-pouch';\n\nconst initialState = {\n  ...states.initial(),\n  user: {\n    username: 'foo',\n    password: 'secret',\n    permissions: {\n      read: true,\n      write: false,\n    }\n  }\n}\n\nexport function myReducer(state = states.initial(), action) {\n  switch (action.type) {\n  case 'LOGGED_IN':\n    // Use the `setInState` to add a logged in user to the state.\n    // This method would override all user values from the previous state \n    return setInState(state, 'user', action.user);\n\n  case 'CHANGE_WRITE_PERMISSION':\n    // You can also `setInState` to set a deep nested value by using a key as an object path   \n    return setInState(state, 'user.write', action.value);\n\n  case 'UPDATE_USER':\n    // To partially update the state object you can use the `mergeInState` function\n    return mergeInState(state, 'user', action.user);\n\n  case 'LOGOUT':\n    // You can delete the value from the store using the `omitInState` function \n    return omitInState(state, 'user');\n  \n  default:\n    return state;\n  }\n}\n</code></pre>","frontmatter":{"id":"redux-reducers","title":"Reducers"}}},{"node":{"html":"<p>These functions are used by reducers to create standard values in the redux store. They represent different states\nthat the data in the store can be in.</p>\n<h4>Example Usage</h4>\n<pre><code class=\"language-javascript\">import * as states from 'bandit-pouch/redux/states';\n\n// Use initial state as a default state in your reducers\nexport function myReducer(state = states.initial(), action) {\n  switch (action.type) {\n  \n  case 'LOADING':\n    // Sets the `loading` property in your state to `true`\n    return states.loading(state);\n  \n  case 'FOUND':\n    // Sets the `loading` property in your state to `false`\n    return states.found({ ...state, model: action.model });\n  \n  case 'ERROR':\n    // Sets the `loading` property in your state to `false`\n    // and adds an error value to your state.\n    return { ...state, ...states.deleted() };\n  \n  case 'SAVING':\n    // Sets the `storing` property in your state to `true`\n    return { ...state, ...states.storing() };\n  \n  case 'SAVED':\n    // Sets the `storing` property in your state to `false`\n    // you can also merge it with your model data from the action\n    return states.stored({ ...state, model: action.model });\n  \n  case 'SAVE_FAILED':\n    // Sets the `storing` property in your state to `false`\n    // and adds an error value to your state. \n    return { ...state, ...states.storeError(action.error) };\n    \n  case 'DELETING':\n    // Sets the `deleting` property in your state to `true`\n    return { ...state, ...states.deleting() };\n  \n  case 'DELETED':\n    // Sets the `deleting` property in your state to `false`\n    return { ...state, ...states.deleted() };\n  \n  case 'REVERTING':\n    // Sets the `reverting` property in your state to `false`\n    return { ...state, ...states.reverting() };\n    \n  case 'REVERTED':\n    // Sets the `reverting` property in your state to `false`\n    return { ...state, ...states.reverted() };\n  \n  default:\n    return state;\n  }\n}\n</code></pre>","frontmatter":{"id":"redux-states","title":"States"}}}]}},"pageContext":{}}